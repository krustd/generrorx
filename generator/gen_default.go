package generator

import (
	"fmt"
	"strings"
)

// DefaultGenerator 默认生成器，不依赖任何框架
type DefaultGenerator struct{}

func (g *DefaultGenerator) Generate(config *Config, entries []*EnumEntry) ([]*OutputFile, error) {
	defaultMsg := config.DefaultHttpMsg
	if defaultMsg == "" {
		defaultMsg = "服务繁忙"
	}

	files := []*OutputFile{
		g.generateTypes(config),
		g.generateErrors(config, entries, defaultMsg),
	}
	return files, nil
}

func (g *DefaultGenerator) generateTypes(config *Config) *OutputFile {
	var b strings.Builder

	fmt.Fprintf(&b, `// Code generated by generrorx; DO NOT EDIT.

package %s

import "fmt"

// Error 统一错误类型
type Error struct {
	code     int    // 后端错误码（细粒度，日志用）
	name     string // 枚举名，如 DB_CONNECT_FAILED（日志用）
	httpCode int    // HTTP 状态码（返回前端）
	httpMsg  string // 前端看到的消息
	cause    error  // 底层错误
}

func newErr(code int, name string, httpCode int, httpMsg string) *Error {
	return &Error{code: code, name: name, httpCode: httpCode, httpMsg: httpMsg}
}

// Error 实现 error 接口，输出后端完整信息
func (e *Error) Error() string {
	if e == nil {
		return ""
	}
	if e.cause != nil {
		return fmt.Sprintf("[%%d/%%s] %%v", e.code, e.name, e.cause)
	}
	return fmt.Sprintf("[%%d/%%s]", e.code, e.name)
}

// Code 返回后端错误码
func (e *Error) Code() int { return e.code }

// Name 返回枚举名
func (e *Error) Name() string { return e.name }

// HttpCode 返回 HTTP 状态码
func (e *Error) HttpCode() int { return e.httpCode }

// HttpMsg 返回前端消息
func (e *Error) HttpMsg() string { return e.httpMsg }

// Unwrap 支持 errors.Unwrap
func (e *Error) Unwrap() error { return e.cause }

// Wrap 包裹底层错误，保留完整链路
func (e *Error) Wrap(err error) *Error {
	return &Error{
		code:     e.code,
		name:     e.name,
		httpCode: e.httpCode,
		httpMsg:  e.httpMsg,
		cause:    err,
	}
}

// WrapMsg 包裹底层错误并覆盖前端消息
func (e *Error) WrapMsg(err error, httpMsg string) *Error {
	return &Error{
		code:     e.code,
		name:     e.name,
		httpCode: e.httpCode,
		httpMsg:  httpMsg,
		cause:    err,
	}
}

// WithMsg 覆盖前端消息（不改变底层错误）
func (e *Error) WithMsg(httpMsg string) *Error {
	return &Error{
		code:     e.code,
		name:     e.name,
		httpCode: e.httpCode,
		httpMsg:  httpMsg,
		cause:    e.cause,
	}
}

// Is 支持 errors.Is 判断（只比较 code）
func (e *Error) Is(target error) bool {
	if t, ok := target.(*Error); ok {
		return e.code == t.code
	}
	return false
}
`, config.PackageName)

	return &OutputFile{
		Path:    "./types.go",
		Content: b.String(),
	}
}

func (g *DefaultGenerator) generateErrors(config *Config, entries []*EnumEntry, defaultMsg string) *OutputFile {
	var b strings.Builder

	fmt.Fprintf(&b, "// Code generated by generrorx; DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "package %s\n\n", config.PackageName)

	// 分组：业务错误 和 内部错误
	var bizEntries, internalEntries []*EnumEntry
	for _, e := range entries {
		if e.IsInternal() {
			internalEntries = append(internalEntries, e)
		} else {
			bizEntries = append(bizEntries, e)
		}
	}

	if len(bizEntries) > 0 {
		fmt.Fprintf(&b, "// ====== 业务错误（返回前端）======\n")
		fmt.Fprintf(&b, "var (\n")
		for _, e := range bizEntries {
			fmt.Fprintf(&b, "\t%s = newErr(%d, %q, %d, %q)\n",
				e.VarName(), e.Code, e.Name, e.HttpCode, e.HttpMsg)
		}
		fmt.Fprintf(&b, ")\n\n")
	}

	if len(internalEntries) > 0 {
		fmt.Fprintf(&b, "// ====== 内部错误（前端统一返回 500）======\n")
		fmt.Fprintf(&b, "var (\n")
		for _, e := range internalEntries {
			comment := e.Comment
			if comment != "" {
				comment = " // " + comment
			}
			fmt.Fprintf(&b, "\t%s = newErr(%d, %q, 500, %q)%s\n",
				e.VarName(), e.Code, e.Name, defaultMsg, comment)
		}
		fmt.Fprintf(&b, ")\n")
	}

	return &OutputFile{
		Path:    "./errors_gen.go",
		Content: b.String(),
	}
}
